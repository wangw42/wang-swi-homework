# 第八次作业

## 阅读 [Pseudocode Standard](http://users.csc.calpoly.edu/~jdalbey/SWE/pdl_std.html).(答案可以打印)

1) 用伪代码描述将十进制转换成16进制的方法
> REAR decimal<br>
count = 0<br>
h[0] = {}<br>
IF decimal < 0 THEN<br>
   Print = '-'<br>
   decimal = -decimal<br>
ENDIF<br>
<br>
IF decimal == 0 THEN<br>
   h[0] = '0'<br>
    count++<br>
ELSE<br>
    j = decimal<br>
    WHILE j<br>
        k = j%16<br>
        IF k<10 THEN<br>
            h[count] = '0'+k<br>
        ELSE<br>
            h[count] = 'A' + k -10<br>
        ENDIF<br>
        j /= 16<br>
        count++<br>
    ENDWHILE<br>
ENDIF<br>
<br>
FOR I = count-1; i >= 0; i--<br>
    Print h[i]<br>
ENDFOR<br>
<br>
Print \n<br>


2) C语言实现（先用注释写好算法，然后翻译）

```c
#include<stdio.h>

int main(){
    int decimal;
    char h[10];
    int i = 0, j,k, count = 0;
    scanf("%d", &decimal);
    //负数时输出符号并将其变为正数
    if(decimal < 0){
        printf("-");
        decimal = -decimal;
    }
    //循环得到十六进制的每一位
    if(decimal == 0 ){
        h[0] = '0';
        count ++;
    }else{
        j = decimal;
        while(j){
            k = j%16;
            if(k<10){
                h[count] = '0' + k;
            }else{
                h[count] = 'A' + k -10;
            }
            j /= 16;
            count++;
        }
    }
    //倒叙输出得到十六进制数
    for(i = count-1; i >= 0; i--){
        printf("%c", h[i]);
    }
    printf("\n");
    
    return 0;
}
```

3) 使用-1, 0, 1, 15, 26, 3625 作为输入测试你的程序<br>

|Input | -1 | 0 | 1 | 15 | 26 | 3265 |
|:--|:--|:--|:--|:--|:--|:--|
|Output | -1 | 0 | 1 | F | 1A | CC1 |

## 名次解释与对比

1) [Top-down design](https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design)(& bottom-up)
>Top-down and bottom-up are both strategies of information processing and knowledge ordering, used in a variety of fields including software, humanistic and scientific theories (see systemics), and management and organization. In practice, they can be seen as a style of thinking, teaching, or leadership.<br>
<br>
A top-down approach (also known as stepwise design and in some cases used as a synonym of decomposition) is essentially the breaking down of a system to gain insight into its compositional sub-systems in a reverse engineering fashion. In a top-down approach an overview of the system is formulated, specifying, but not detailing, any first-level subsystems. Each subsystem is then refined in yet greater detail, sometimes in many additional subsystem levels, until the entire specification is reduced to base elements. A top-down model is often specified with the assistance of "black boxes", which makes it easier to manipulate. However, black boxes may fail to clarify elementary mechanisms or be detailed enough to realistically validate the model. Top down approach starts with the big picture. It breaks down from there into smaller segments.<br>
<br>
A bottom-up approach is the piecing together of systems to give rise to more complex systems, thus making the original systems sub-systems of the emergent system. Bottom-up processing is a type of information processing based on incoming data from the environment to form a perception. From a cognitive psychology perspective, information enters the eyes in one direction (sensory input, or the "bottom"), and is then turned into an image by the brain that can be interpreted and recognized as a perception (output that is "built up" from processing to final cognition). In a bottom-up approach the individual base elements of the system are first specified in great detail. These elements are then linked together to form larger subsystems, which then in turn are linked, sometimes in many levels, until a complete top-level system is formed. This strategy often resembles a "seed" model, by which the beginnings are small but eventually grow in complexity and completeness. However, "organic strategies" may result in a tangle of elements and subsystems, developed in isolation and subject to local optimization as opposed to meeting a global purpose.
<br>

2) [Work breakdown structure(WBS)](https://en.wikipedia.org/wiki/Work_breakdown_structure)
>A work-breakdown structure (WBS)[2] in project management and systems engineering, is a deliverable-oriented breakdown of a project into smaller components. A work breakdown structure is a key project deliverable that organizes the team's work into manageable sections. 

3) 简述管理学WBS与信息学Top-down设计的异同<br>
同：都是将问题逐层分解，化大为小，将大问题分解来解决。<br>
异：Top-down是自顶向下，WBS是按照类型分
<br>


## 仔细观察洗衣机的运作过程，运用Top-down设计方法和Pseudocode描述洗衣机控制程序。假设洗衣机可执行的基本操作如下：
water_in_switch(open_close) //open打开上水开关，close关闭<br>
water_out_switch(open_close) //open打开排水开关，close关闭<br>
get_water_volume() //返回洗衣机内部水的高度<br>
motor_run(direction) //点击转动。left左转，right右转，stop停<br>
timer_counter() //返回当前时间计数，以秒为单位<br>
halt(returncode) //停机，success成功failure失败

1) 请用伪代码分解“正常洗衣”程序的大步骤。包括注水、浸泡等<br>
>注水 -> 浸泡-> 转动洗衣-> 转动脱水-> 排水<br>
<br>
water_in_switch(open）<br>
get_water_volume()<br>
water_in_switch(close)<br>
<br>
motorrun(left)<br>
motorrun(right)<br>
motorrun(stop)<br>
<br>
water_out_switch(open）<br>
motorrun(left)<br>
motorrun(right)<br>
motorrun(stop)<br>
<br>
get_water_volume()<br>
water_out_switch(close)<br>


2) 进一步用基本操作、控制语句、变量与表达式，写出每个步骤的伪代码<br>
>READ(water,timer)<br>
WHILE get_water_volume() < water<br>
  water_in_switch(open)<br>
ENDWHILE<br>
water_in_switch(close)<br>
<br>
WHILE nowtime <= timer<br>
	motorrun(left)<br>
	motorrun(right)<br>
	motorrun(stop)<br>
    IF get_water_volume() > 0 <br>
	    water_out_switch(open）<br>
        motorrun(left)<br>
        motorrun(right)<br>
        motorrun(stop)<br>
        IF get_water_volume() == 0<br>
            water_out_switch(close)<br>
        ENDIF<br>
    ENDIF<br>



3) 根据你的实践，请分析“正常洗衣“与”快速洗衣“在用户目标和程序设计上的异同。你认为是否存在改进空间，简单
说明你的改进意见？<br>
>正常洗衣就是模糊控制程序，机器根据衣服的多少自动设定水位和洗涤时间，经过一洗二漂三甩干，最后达到国家制造标准规定的洗净度指标，这种方法洗的衣服是最干净的，用水用电也是最合理的。快洗是适用不太脏的衣服，洗衣粉要放得很少甚至不放，机器执行一洗一漂一甩干，用时也较短。<br>
<br>
可以将其升级为更多的模式，把整体的步骤分块进行，如只进行期中某个步骤，以适用于各种条件和各种类型的衣物。

4) 通过步骤3，提取一些共性功能模块（函数），简化”正常洗衣“程序，使程序变得更利于人类理解和修改维护。例如: <br>
wait(time)//等待指定的时间; <br>
注水(volume,timeout)//在指定时间内完成注水，否则停机；<br>
排水(timeout)。等子程序<br>
>FUNCTION wait(time)<br>
  now = timer();<br>
  WHILE timer() <= now+time<br>
  ENDWHILE<br>
ENDFUNCTION<br>