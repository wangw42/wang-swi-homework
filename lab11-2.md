# 11-2-一些排序算法

## [冒泡排序](#1)
## [选择排序](#2)
## [插入排序](#3)
## [桶排序](#4)

*这里简单整理了最常用和简单的几种排序。其他可参考博客末尾的Reference。*

|排序方法| 冒泡排序| 选择排序| 插入排序|桶排序 |
|:-- |:-- |:-- |:-- |:--|
| 时间复杂度|$$ O(n^2) $$ | $$ O(n^2) $$| $$ O(n^2) $$|$$ O(n+k) $$ |

<br>
<h3 id="1">冒泡排序（Bubble Sort） </h3>

* 比较相邻的元素。并根据想要排序的大小交换它们两个；
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的 最后一对，这样在最后的元素应该会是最大或是最小的数；
* 针对所有的元素重复以上的步骤，除了最后一个；
* 重复步骤1~3，直到排序完成。

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

主要代码：
```c
for (i = 0; i < len - 1; i++) {
    for (j = 0; j < len - 1 - i; j++) {
        if (arr[j] > arr[j+1]) {         
            temp = arr[j+1];  
            arr[j+1] = arr[j];
            arr[j] = temp;
        }
    }
}
```


<h3 id="2">选择排序（Selection Sort） </h3>

* 遍历数组，遍历到i时，a0,a1...ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

主要代码：
```c
for (i = 0; i < len-1; i++) {
        for (pos = i, j = i+1; j < n; j++)
            if (a[pos] > a[j])
                pos = j;
        if (pos != i) {
            temp = a[i];
            a[i] = a[pos];
            a[pos] = temp;
        }
    }
```

<h3 id="3">插入排序（Insertion Sort） </h3>

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

* 从第一个元素开始，该元素可以认为已经被排序
* 取出下一个元素，在已经排序的元素序列中从后向前扫描
* 如果该元素（已排序）大于新元素，将该元素移到下一位置
* 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
* 将新元素插入到该位置后
* 重复步骤2~5

<h3 id="4">桶排序（Bucket Sort） </h3>

* 设置一个定量的数组当作空桶；
* 遍历输入数据，并且把数据一个一个放到对应的桶里去；
* 对每个不是空的桶进行排序；
* 从不是空的桶里把排好序的数据拼接起来。

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png)

eg.简单的使用桶排序的题，如c程序设计课程期中考试题目。




Reference:<br>
[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)<br>
[常用排序算法总结(一)](https://www.cnblogs.com/eniac12/p/5329396.html#s3)

